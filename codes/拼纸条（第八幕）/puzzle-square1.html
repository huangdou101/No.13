<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>层叠拼图</title>
  <!-- 引入 Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- 引入 Font Awesome 图标 -->
  <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link rel="stylesheet" href="../层叠消融/css/puzzle.css"/>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=VT323&display=swap" rel="stylesheet">
  <style>
    .puzzle-piece {
      position: absolute;
      cursor: move;
      display: flex;
      align-items: center;
      justify-content: center;
      color: rgba(0, 0, 0, 0.3);
      font-weight: bold;
      border: 2px solid;
      user-select: none;
      transition: transform 0.1s ease;
      z-index: 10; /* 拼图块基础层级 */
    }
    .puzzle-piece:active {
      transform: scale(1.02);
      z-index: 30; /* 拖动时临时提升层级 */
    }
    #puzzleArea {
      position: relative;
      background-image: linear-gradient(#f2f2f2 1px, transparent 1px),
                        linear-gradient(90deg, #f2f2f2 c 1px, transparent 1px);
      background-size: 40px 40px;
      background-color: #f0f0f0; /* 拼图区底色 - 浅灰色 */
      overflow: hidden;
    }
    /* 网格定位点 */
    .grid-dot {
      position: absolute;
      width: 4px;
      height: 4px;
      background-color: #d97706;
      border-radius: 50%;
      transform: translate(-50%, -50%);
      pointer-events: none;
      z-index: 50; /* 定位点在最上层 */
    }
    .control-btn {
      transition: all 0.2s ease;
    }
    .control-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
    }
    /* 重叠区域画布 - 关键：确保在拼图块上方 */
    #overlapCanvas {
      position: absolute;
      top: 0;
      left: 0;
      pointer-events: none;
      z-index: 20; /* 高于拼图块基础层级，低于拖动时的临时层级 */
    }
    /* 目标图形网格画布 */
    #targetCanvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      opacity: 0; /* 默认为透明，调试时可改为0.5 */
      pointer-events: none;
    }
    /* 调试用：显示网格线 */
    .debug-grid .puzzle-piece {
      background-color: rgba(6, 182, 212, 0.7);
    }
    /* 提示视频容器样式 */
    .hint-video-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.8);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 100;
      opacity: 0;
      visibility: hidden;
      transition: all 0.3s ease;
    }
    .hint-video-container.active {
      opacity: 1;
      visibility: visible;
    }
    .video-wrapper {
      position: relative;
      width: 80%;
      max-width: 800px;
    }
    .close-video {
      position: absolute;
      top: -40px;
      right: 0;
      color: white;
      background: none;
      border: none;
      font-size: 24px;
      cursor: pointer;
      width: 36px;
      height: 36px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 50%;
      background-color: rgba(255, 255, 255, 0.2);
    }
    .close-video:hover {
      background-color: rgba(255, 255, 255, 0.4);
    }
    video {
      width: 100%;
      border-radius: 8px;
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
    }
  </style>
</head>

<body class="min-h-screen">
  <div class="container mx-auto px-4 py-8 max-w-6xl">
    <h1 class="text-3xl pixel-font font-bold text-center mb-8 text-red-600 ">PUZZLE CLUE</h1>
    <div class="flex flex-row gap-8">
      <!-- 左侧区域 -->
      <div class="w-1/4 flex flex-col gap-4">
        <!-- 规则说明 -->
        <div class="bg-[#708090] p-4 rounded-lg shadow-md">
          <p class="text-xl font-semibold text-center text-[#FFFFF0]">规则：偶消奇不消</p>
        </div>
        
        <!-- 目标图区 -->
        <div class="bg-[#708090] p-4 rounded-lg shadow-md flex-grow">
          <h2 class="text-xl font-semibold mb-4 text-[#DEB887]">目标图形</h2>
          <div id="targetArea" class="w-full h-64 bg-white rounded-md border border-gray-300 relative">
            <img src="target1.jpg" alt="目标图形" class="max-w-full max-h-full object-contain">
            <!-- 隐藏的目标图形网格画布 -->
            <canvas id="targetCanvas"></canvas>
          </div>
        </div>
        
        <!-- 倒计时和提示按钮 -->
        <div class="bg-[#708090] p-4 rounded-lg shadow-md">
          <div class="flex justify-between items-center mb-3">
            <h3 class="font-semibold text-[#FFFFF0]">倒计时</h3>
            <div id="timer" class="bg-yellow-100 font-mono font-semibold text-red-600">01:30</div>
          </div>
          <button id="hintBtn" class="control-btn w-full bg-blue-500 hover:bg-blue-600 text-white py-2 px-4 rounded-md flex items-center justify-center gap-2">
            <i class="fa fa-lightbulb-o"></i>
            <span>提示</span>
          </button>
          <!-- 调试按钮 
         <button id="resetBtn" class="reset-btn w-full mt-2 bg-gray-500 hover:bg-gray-600 text-white py-2 px-4 rounded-md">
             重置
          </button>-->
        </div>
      </div>
      
      <!-- 中间拼图区 -->
      <div class="w-2/4">
        <div class="bg-[#D2B48C] p-4 rounded-lg shadow-md h-full">
          <h2 class="text-2xl text-center font-semibold  mb-4 text-[#8B008B]">拼图区</h2>
          <div id="puzzleArea" class="w-full h-[calc(100%-50px)] min-h-[600px] rounded-md border border-[##ffe8d6]">
            <!-- 网格定位点会通过JS生成 -->
            <!-- 重叠区域画布 -->
            <canvas id="overlapCanvas"></canvas>
          </div>
        </div>
      </div>
      
      <!-- 右侧区域 -->
      <div class="w-1/4 flex flex-col gap-4">
        <!-- 拼图块摆放区 -->
        <div class="bg-[#708090] p-4 rounded-lg shadow-md flex-grow">
          <h2 class="text-2xl text-center font-semibold mb-4 text-[#DEB887]">拼图块</h2>
          <div id="pieceContainer" class="w-full h-64 bg-[#778899] rounded-md flex flex-wrap justify-center items-center gap-4 border border-[#778899]">
            <!-- 拼图块会通过JS生成 -->
          </div>
        </div>
        
        <!-- 操作说明 -->
        <div class="bg-[#708090] p-4 rounded-lg shadow-md">
          <p class="text-center text-white font-medium">
            <i class="fa fa-hand-pointer-o text-orange-500 mr-2"></i>
            鼠标拖动拼图块，自动对齐到网格
          </p>
        </div>
      </div>
    </div>
  </div>

  <!-- 提示视频容器 -->
  <div class="hint-video-container" id="hintVideoContainer">
    <div class="video-wrapper">
      <button class="close-video" id="closeVideoBtn">×</button>
      <video id="hintVideo" controls>
        <source src="hint1.mp4" type="video/mp4">
        您的浏览器不支持视频播放
      </audio>
    </div>
  </div>
  <div id="successModal" class="fixed inset-0 bg-black/80 flex items-center justify-center z-50 hidden">
  <div class="bg-red-600 text-white p-8 rounded-lg text-center shadow-2xl transform transition-all">
    <h2 class="text-4xl font-bold pixel-font mb-4">恭喜你！得到线索！</h2>
    <p class="text-2xl font-bold">按‘空格’查看线索</p>
    <button onclick="document.getElementById('successModal').classList.add('hidden')" class="mt-6 bg-white text-red-600 px-6 py-2 rounded-md font-bold">确定</button>
  </div>
</div>

  <script>
    // 当页面加载完成后执行
    document.addEventListener('DOMContentLoaded', function () {
      // 配置参数 - 网格大小为40px
      const gridSize = 40; 
      // 拼图区底色（与CSS中保持一致）
      const puzzleAreaColor = '#ffe8d6';
      // 目标图形网格数据 - 将通过图片生成
      let targetShapeData;
      // 形状匹配的容差率(%)
      const matchTolerance = 10;
      // 标记是否已经完成匹配
      let isCompleted = false;
      // 启用高精度网格计算
      const highPrecisionMode = true;
      // 网格覆盖率阈值（0-1），高于此值才认为该网格被覆盖
      const coverageThreshold = 0.5;
      // 提示视频是否已经播放过
      let hintVideoPlayed = false;
      
      // 获取元素
      const puzzleArea = document.getElementById('puzzleArea');
      const pieceContainer = document.getElementById('pieceContainer');
      const timerDisplay = document.getElementById('timer');
      const hintBtn = document.getElementById('hintBtn');
      const debugBtn = document.getElementById('debugBtn');
      const overlapCanvas = document.getElementById('overlapCanvas');
      const ctx = overlapCanvas.getContext('2d');
      const targetArea = document.getElementById('targetArea');
      const targetCanvas = document.getElementById('targetCanvas');
      const targetCtx = targetCanvas.getContext('2d');
      // 提示视频相关元素
      const hintVideoContainer = document.getElementById('hintVideoContainer');
      const hintVideo = document.getElementById('hintVideo');
      const closeVideoBtn = document.getElementById('closeVideoBtn');
      
      // 从图片生成目标形状数据
      function generateTargetShapeData(imageUrl, gridRows, gridCols, threshold = 0.3) {
        return new Promise((resolve, reject) => {
          const img = new Image();
          img.crossOrigin = "anonymous"; // 处理跨域图片
          img.onload = function() {
            // 创建临时画布
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            // 设置画布大小与图片一致
            canvas.width = img.width;
            canvas.height = img.height;
            
            // 绘制图片
            ctx.drawImage(img, 0, 0);
            
            // 获取图像数据
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const pixels = imageData.data;
            
            // 计算每个网格单元的尺寸
            const cellWidth = canvas.width / gridCols;
            const cellHeight = canvas.height / gridRows;
            
            // 初始化形状数据数组
            const shapeData = Array.from({ length: gridRows }, () => 
              Array.from({ length: gridCols }, () => 0)
            );
            
            // 分析每个网格单元
            for (let row = 0; row < gridRows; row++) {
              for (let col = 0; col < gridCols; col++) {
                // 计算当前网格的像素范围
                const startX = Math.floor(col * cellWidth);
                const startY = Math.floor(row * cellHeight);
                const endX = Math.floor((col + 1) * cellWidth);
                const endY = Math.floor((row + 1) * cellHeight);
                
                // 统计非透明像素数量
                let nonTransparentPixels = 0;
                let totalPixels = 0;
                
                // 遍历网格内的像素
                for (let y = startY; y < endY; y++) {
                  for (let x = startX; x < endX; x++) {
                    // 确保不超出画布范围
                    if (x < canvas.width && y < canvas.height) {
                      const index = (y * canvas.width + x) * 4;
                      const alpha = pixels[index + 3]; // 透明度通道
                      
                      // 如果像素不透明（alpha > 0），视为图案部分
                      if (alpha > 0) {
                        nonTransparentPixels++;
                      }
                      totalPixels++;
                    }
                  }
                }
                
                // 如果非透明像素比例超过阈值，标记为1
                if (totalPixels > 0 && nonTransparentPixels / totalPixels > threshold) {
                  shapeData[row][col] = 1;
                }
              }
            }
            
            resolve(shapeData);
          };
          
          // 图片加载错误处理
          img.onerror = function(error) {
            reject(error);
          };
          
          // 加载图片
          img.src = imageUrl;
        });
      }
      
      // 创建网格定位点
      function createGridDots() {
        const rect = puzzleArea.getBoundingClientRect();
        const width = rect.width;
        const height = rect.height;
        
        // 清除现有定位点
        document.querySelectorAll('.grid-dot').forEach(dot => dot.remove());
        
        // 创建新的定位点（网格交点）
        for (let x = 0; x <= width; x += gridSize) {
          for (let y = 0; y <= height; y += gridSize) {
            const dot = document.createElement('div');
            dot.className = 'grid-dot';
            dot.style.left = `${x}px`;
            dot.style.top = `${y}px`;
            puzzleArea.appendChild(dot);
          }
        }
      }
      
      // 设置画布大小与拼图区一致
      function resizeCanvas() {
        // 设置拼图区画布
        const { width, height } = puzzleArea.getBoundingClientRect();
        overlapCanvas.width = width;
        overlapCanvas.height = height;
        overlapCanvas.style.width = `${width}px`;
        overlapCanvas.style.height = `${height}px`;
        
        // 设置目标区画布
        const targetRect = targetArea.getBoundingClientRect();
        targetCanvas.width = targetRect.width;
        targetCanvas.height = targetRect.height;
        targetCanvas.style.width = `${targetRect.width}px`;
        targetCanvas.style.height = `${targetRect.height}px`;
        
        // 如果目标形状数据已加载，绘制目标网格
        if (targetShapeData) {
          drawTargetGrid();
        }
        
        createGridDots(); // 重新创建网格点
      }
      
      // 绘制目标图形的网格表示（用于匹配检测）
      function drawTargetGrid() {
        if (!targetShapeData) return;
        
        const rect = targetArea.getBoundingClientRect();
        const cellWidth = rect.width / targetShapeData[0].length;
        const cellHeight = rect.height / targetShapeData.length;
        
        targetCtx.clearRect(0, 0, rect.width, rect.height);
        
        // 绘制目标图形的网格（实际不可见，仅用于计算）
        for (let row = 0; row < targetShapeData.length; row++) {
          for (let col = 0; col < targetShapeData[row].length; col++) {
            if (targetShapeData[row][col] === 1) {
              targetCtx.fillStyle = '#000';
              targetCtx.fillRect(
                col * cellWidth,
                row * cellHeight,
                cellWidth,
                cellHeight
              );
            }
          }
        }
      }
      
      // 初始化 - 从图片生成目标形状数据
      generateTargetShapeData('target1.jpg', 6, 6, 0.3)
        .then(data => {
          targetShapeData = data;
          console.log('目标形状数据生成成功:', targetShapeData);
          resizeCanvas(); // 初始化画布
        })
        .catch(error => {
          console.error('生成目标形状数据失败:', error);
          // 加载失败时使用默认形状
          targetShapeData = [
            [0,0,1,1,0,0],
            [0,0,1,1,1,0],
            [0,0,1,1,1,0],
            [0,1,0,0,0,0],
            [1,0,0,0,0,0],
            [0,0,0,0,0,0]
          ];
          resizeCanvas(); // 使用默认数据初始化画布
        });
      
      window.addEventListener('resize', () => {
        resizeCanvas();
        checkOverlap();
      });
      
      // 拼图块的数量和颜色
      const pieceCount = 5;
      const pieceColors = [//青色
        '#06b6d4', 
        '#06b6d4', 
        '#06b6d4', 
        '#06b6d4', 
        '#06b6d4'
      ];
      
      // 拼图块尺寸（基于网格的倍数）
      const pieceSizes = [
        {w: 4, h: 4}, // 4x4网格
        {w: 2, h: 3}, // 2x3网格
        {w: 2, h: 3}, // 2x3网格
        {w: 3, h: 2}, // 3x2网格
        {w: 3, h: 2}, // 3x2网格
      ];
      
      // 存储所有拼图块信息
      const pieces = [];
      let timerInterval;
      let remainingTime = 90; // 90秒倒计时
      
      // 初始化倒计时
      function startTimer() {
        updateTimerDisplay();
        timerInterval = setInterval(() => {
          remainingTime--;
          updateTimerDisplay();
          
          if (remainingTime <= 0) {
            clearInterval(timerInterval);
            alert('时间到！游戏结束');
          }
        }, 1000);
      }
      
      // 更新倒计时显示
      function updateTimerDisplay() {
        const minutes = Math.floor(remainingTime / 60);
        const seconds = remainingTime % 60;
        timerDisplay.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
      }
      
      // 强制对齐到最近的网格位置（不允许偏离）
      function forceSnapToGrid(value) {
        // 计算最近的网格坐标，不允许有任何偏离
        return Math.round(value / gridSize) * gridSize;
      }
      
      // 创建拼图块
      for (let i = 0; i < pieceCount; i++) {
        const piece = document.createElement('div');
        const size = pieceSizes[i];
        const width = size.w * gridSize;
        const height = size.h * gridSize;
        
        piece.className = 'puzzle-piece shadow-md';
        piece.style.width = `${width}px`;
        piece.style.height = `${height}px`;
        piece.style.backgroundColor = pieceColors[i];
        piece.style.borderColor = shadeColor(pieceColors[i], -30);
        piece.innerHTML = `<span>${i+1}</span>`;
        piece.dataset.index = i;
        piece.dataset.id = `piece-${i}`;
        piece.dataset.width = size.w;
        piece.dataset.height = size.h;
        
        pieceContainer.appendChild(piece);
        pieces.push({
          element: piece,
          color: pieceColors[i],
          id: `piece-${i}`,
          width: width,
          height: height,
          gridWidth: size.w,
          gridHeight: size.h
        });
        
        // 为拼图块添加鼠标事件
        piece.addEventListener('mousedown', function (e) {
          if (isCompleted) return; // 如果已完成，不允许再拖动
          
          e.preventDefault();
          
          // 获取拼图块和拼图区的位置信息
          const pieceRect = piece.getBoundingClientRect();
          const puzzleAreaRect = puzzleArea.getBoundingClientRect();
          
          // 计算鼠标在拼图块内的相对位置
          const offsetX = e.clientX - pieceRect.left;
          const offsetY = e.clientY - pieceRect.top;
          
          // 保存原始层级以便释放时恢复
          const originalZIndex = piece.style.zIndex || '10';
          
          // 将当前块置于临时顶层（但低于画布）
          piece.style.zIndex = '30';
          
          const originalParent = piece.parentNode;
          let isInPuzzleArea = originalParent === puzzleArea;
          
          // 鼠标移动事件
          function onMouseMove(moveEvent) {
            const areaRect = puzzleArea.getBoundingClientRect();
            
            // 计算当前鼠标位置
            let x = moveEvent.clientX - areaRect.left - offsetX;
            let y = moveEvent.clientY - areaRect.top - offsetY;
            
            // 更新拼图块位置
            piece.style.left = `${x}px`;
            piece.style.top = `${y}px`;
            
            // 如果从容器中拖动，移至拼图区
            if (originalParent === pieceContainer && !isInPuzzleArea) {
              piece.style.position = 'absolute';
              puzzleArea.appendChild(piece);
              isInPuzzleArea = true;
            }
          }
          
          // 鼠标释放事件
          function onMouseUp() {
            document.removeEventListener('mousemove', onMouseMove);
            document.removeEventListener('mouseup', onMouseUp);
            
            // 恢复原始层级
            piece.style.zIndex = originalZIndex;
            
            // 释放鼠标时强制对齐到最近的网格点
            if (isInPuzzleArea) {
              const areaRect = puzzleArea.getBoundingClientRect();
              const x = parseFloat(piece.style.left);
              const y = parseFloat(piece.style.top);
              
              // 强制对齐到网格
              const snappedX = forceSnapToGrid(x);
              const snappedY = forceSnapToGrid(y);
              
              // 确保拼图块不会超出拼图区边界
              const maxX = areaRect.width - piece.offsetWidth;
              const maxY = areaRect.height - piece.offsetHeight;
              const finalX = Math.max(0, Math.min(snappedX, maxX));
              const finalY = Math.max(0, Math.min(snappedY, maxY));
              
              // 更新到最终对齐位置
              piece.style.left = `${finalX}px`;
              piece.style.top = `${finalY}px`;
              
              // 检查重叠区域和形状匹配
              checkOverlap();
              checkShapeMatch();
            }
          }
          
          document.addEventListener('mousemove', onMouseMove);
          document.addEventListener('mouseup', onMouseUp);
        });
      }
      
      // 提示按钮功能 - 播放视频提示
      hintBtn.addEventListener('click', function() {
        if (isCompleted) return;
        
        // 显示视频容器并播放视频
        hintVideoContainer.classList.add('active');
        hintVideo.play();
        
        // 第一次播放提示视频扣减时间
        if (!hintVideoPlayed) {
          hintVideoPlayed = true;
          if (remainingTime > 30) {
            remainingTime -= 30; // 播放提示扣10秒
            updateTimerDisplay();
          } else {
            remainingTime = 0;
            updateTimerDisplay();
            clearInterval(timerInterval);
          }
        }
      });
      
      // 关闭视频按钮
      closeVideoBtn.addEventListener('click', function() {
        hintVideoContainer.classList.remove('active');
        hintVideo.pause();
      });
      
      // 视频播放结束时自动关闭
      hintVideo.addEventListener('ended', function() {
        hintVideoContainer.classList.remove('active');
      });
      
      // 调试按钮功能
//      debugBtn.addEventListener('click', function() {
//      puzzleArea.classList.toggle('debug-grid');
//        targetCanvas.style.opacity = puzzleArea.classList.contains('debug-grid') ? '0.5' : '0';
//        checkOverlap(); // 重新绘制重叠区域
//      });
      
      // 高精度检查重叠区域 - 解决格子误消问题
      function checkOverlap() {
        // 清除画布
        ctx.clearRect(0, 0, overlapCanvas.width, overlapCanvas.height);
        
        const puzzlePieces = puzzleArea.querySelectorAll('.puzzle-piece');
        if (puzzlePieces.length === 0) return;
        
        const pieceRects = [];
        const areaRect = puzzleArea.getBoundingClientRect();
        const cellSize = gridSize;
        const gridWidth = Math.ceil(areaRect.width / cellSize);
        const gridHeight = Math.ceil(areaRect.height / cellSize);
        
        // 初始化重叠网格 - 使用浮点数存储覆盖率
        const coverageGrid = Array.from({ length: gridHeight }, () => 
          Array.from({ length: gridWidth }, () => 0)
        );
        
        // 获取每个拼图块的精确位置和尺寸（考虑边框）
        puzzlePieces.forEach(piece => {
          const style = window.getComputedStyle(piece);
          const borderWidth = parseInt(style.borderWidth);
          
          const rect = piece.getBoundingClientRect();
          const left = rect.left - areaRect.left + borderWidth;
          const top = rect.top - areaRect.top + borderWidth;
          const right = rect.right - areaRect.left - borderWidth;
          const bottom = rect.bottom - areaRect.top - borderWidth;
          
          // 高精度模式：计算每个网格被拼图块覆盖的精确比例
          if (highPrecisionMode) {
            // 遍历拼图块覆盖的所有网格
            const startCol = Math.max(0, Math.floor(left / cellSize));
            const endCol = Math.min(gridWidth - 1, Math.floor(right / cellSize));
            const startRow = Math.max(0, Math.floor(top / cellSize));
            const endRow = Math.min(gridHeight - 1, Math.floor(bottom / cellSize));
            
            // 计算拼图块的实际矩形区域
            const pieceRect = {
              x1: left,
              y1: top,
              x2: right,
              y2: bottom
            };
            
            // 对每个可能重叠的网格进行精确计算
            for (let row = startRow; row <= endRow; row++) {
              for (let col = startCol; col <= endCol; col++) {
                // 计算当前网格的矩形区域
                const gridRect = {
                  x1: col * cellSize,
                  y1: row * cellSize,
                  x2: (col + 1) * cellSize,
                  y2: (row + 1) * cellSize
                };
                
                // 计算拼图块与网格的重叠面积
                const overlapArea = calculateOverlapArea(pieceRect, gridRect);
                const gridArea = cellSize * cellSize;
                const coverage = overlapArea / gridArea;
                
                // 只有当覆盖率超过阈值时，才计入覆盖
                if (coverage > coverageThreshold) {
                  coverageGrid[row][col]++;
                }
              }
            }
          } else {
            // 普通模式：简单判断网格是否被覆盖
            const startCol = Math.floor(left / cellSize);
            const endCol = Math.floor(right / cellSize);
            const startRow = Math.floor(top / cellSize);
            const endRow = Math.floor(bottom / cellSize);
            
            for (let row = startRow; row <= endRow; row++) {
              for (let col = startCol; col <= endCol; col++) {
                if (row >= 0 && row < gridHeight && col >= 0 && col < gridWidth) {
                  coverageGrid[row][col]++;
                }
              }
            }
          }
        });
        
        // 绘制偶数重叠区域（棕黄色，显示在拼图块上层）
        ctx.fillStyle = puzzleAreaColor;
        ctx.globalCompositeOperation = 'source-over';
        
        // 调试模式下绘制网格线
        if (puzzleArea.classList.contains('debug-grid')) {
          ctx.strokeStyle = 'rgba(255, 0, 0, 0.3)';
          ctx.lineWidth = 1;
        }
        
        for (let row = 0; row < gridHeight; row++) {
          for (let col = 0; col < gridWidth; col++) {
            // 绘制偶数重叠区域
            if (coverageGrid[row][col] > 0 && coverageGrid[row][col] % 2 === 0) {
              ctx.fillRect(
                col * cellSize, 
                row * cellSize, 
                cellSize, 
                cellSize
              );
            }
            
            // 调试模式下绘制网格线
            if (puzzleArea.classList.contains('debug-grid')) {
              ctx.strokeRect(
                col * cellSize, 
                row * cellSize, 
                cellSize, 
                cellSize
              );
              
              // 显示网格覆盖计数
              ctx.fillStyle = 'red';
              ctx.font = '10px Arial';
              ctx.fillText(coverageGrid[row][col], 
                col * cellSize + 5, 
                row * cellSize + 15
              );
              ctx.fillStyle = puzzleAreaColor; // 恢复填充色
            }
          }
        }
        
        return coverageGrid;
      }
      
      // 计算两个矩形的重叠面积
      function calculateOverlapArea(rect1, rect2) {
        // 计算重叠区域的坐标
        const x1 = Math.max(rect1.x1, rect2.x1);
        const y1 = Math.max(rect1.y1, rect2.y1);
        const x2 = Math.min(rect1.x2, rect2.x2);
        const y2 = Math.min(rect1.y2, rect2.y2);
        
        // 如果没有重叠，返回0
        if (x1 >= x2 || y1 >= y2) {
          return 0;
        }
        
        // 计算重叠面积
        return (x2 - x1) * (y2 - y1);
      }
      
      // 检查拼图结果与目标图形是否匹配
      function checkShapeMatch() {
        if (isCompleted || !targetShapeData) return;
        
        // 获取当前拼图的形状数据
        const currentGrid = checkOverlap();
        if (!currentGrid) return;
        
        // 找出当前拼图的边界框
        let minRow = currentGrid.length, maxRow = -1;
        let minCol = currentGrid[0].length, maxCol = -1;
        
        // 找到有内容的网格范围
        for (let row = 0; row < currentGrid.length; row++) {
          for (let col = 0; col < currentGrid[row].length; col++) {
            if (currentGrid[row][col] % 2 === 1) { // 奇数重叠区域
              minRow = Math.min(minRow, row);
              maxRow = Math.max(maxRow, row);
              minCol = Math.min(minCol, col);
              maxCol = Math.max(maxCol, col);
            }
          }
        }
        
        // 如果没有拼图，直接返回
        if (maxRow === -1) return;
        
        // 提取当前拼图的形状（标准化大小）
        const currentShape = [];
        for (let row = minRow; row <= maxRow; row++) {
          const shapeRow = [];
          for (let col = minCol; col <= maxCol; col++) {
            // 1表示有颜色（奇数重叠），0表示无颜色
            shapeRow.push(currentGrid[row][col] % 2 === 1 ? 1 : 0);
          }
          currentShape.push(shapeRow);
        }
        
        // 比较当前形状与目标形状
        const matchPercentage = calculateShapeSimilarity(currentShape, targetShapeData);
        
        // 如果匹配度超过容差，判定为匹配成功
        if (matchPercentage >= (100 - matchTolerance)) {
          isCompleted = true;
          clearInterval(timerInterval);
        // 替换原来的alert部分
        // alert('恭喜你，得到线索！');
        document.getElementById('successModal').classList.remove('hidden');
        }
      }
      
      // 计算两个形状的相似度百分比
      function calculateShapeSimilarity(shape1, shape2) {
        // 如果形状大小差异太大，直接返回低相似度
        const heightRatio = Math.abs(shape1.length - shape2.length) / Math.max(shape1.length, shape2.length);
        const widthRatio = Math.abs(shape1[0].length - shape2[0].length) / Math.max(shape1[0].length, shape2[0].length);
        
        if (heightRatio > 0.3 || widthRatio > 0.3) {
          return 0;
        }
        
        // 计算形状的总面积（像素点数量）
        let totalPoints = 0;
        let matchingPoints = 0;
        
        // 比较两个形状的每个点
        for (let i = 0; i < Math.max(shape1.length, shape2.length); i++) {
          for (let j = 0; j < Math.max(shape1[0].length, shape2[0].length); j++) {
            // 检查点是否在两个形状范围内
            const inShape1 = i < shape1.length && j < shape1[i].length;
            const inShape2 = i < shape2.length && j < shape2[i].length;
            
            // 如果点在任意一个形状内，计入总点数
            if (inShape1 || inShape2) {
              totalPoints++;
              
              // 获取两个形状在该点的值（0或1）
              const val1 = inShape1 ? shape1[i][j] : 0;
              const val2 = inShape2 ? shape2[i][j] : 0;
              
              // 如果值相同，计入匹配点数
              if (val1 === val2) {
                matchingPoints++;
              }
            }
          }
        }
        
        // 返回相似度百分比
        return totalPoints > 0 ? (matchingPoints / totalPoints) * 100 : 0;
      }
      
      // 辅助函数：调整颜色明暗
      function shadeColor(color, percent) {
        let R = parseInt(color.substring(1, 3), 16);
        let G = parseInt(color.substring(3, 5), 16);
        let B = parseInt(color.substring(5, 7), 16);

        R = parseInt(R * (100 + percent) / 100);
        G = parseInt(G * (100 + percent) / 100);
        B = parseInt(B * (100 + percent) / 100);

        R = (R < 255) ? R : 255;
        G = (G < 255) ? G : 255;
        B = (B < 255) ? B : 255;

        R = Math.round(R);
        G = Math.round(G);
        B = Math.round(B);

        const RR = ((R.toString(16).length === 1) ? "0" + R.toString(16) : R.toString(16));
        const GG = ((G.toString(16).length === 1) ? "0" + G.toString(16) : G.toString(16));
        const BB = ((B.toString(16).length === 1) ? "0" + B.toString(16) : B.toString(16));

        return `#${RR}${GG}${BB}`;
      }
      
      // 开始倒计时
      startTimer();
    });
  </script>
</body>

</html>